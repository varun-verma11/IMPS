if modularity



High-level features like modularity is used in the code. Some of the methods which are common to the debugger and the emulator have been included using the include statements for those header files which provides the implemenation of the complete IMPS project higher modularity. Since if any of the methods whicih has to be changed would only be changed once and not once for each emulator, assembler and debugger. The code for executing all the instruction is in the file 'carryOutInstruction.c', this allows the adding of instructions in the instruction set to be easy. The user can add their own defined functions which might be specific to their tasks. This eliminates the user to still asseemble without changing much of the code for the assembler. 

The main challenge which we encountered as a group when we started doing the function to allow the user to step back. The first solution we though was to make a double linked list and store each state of the processor but this idea was dropped due to the amount of memory which could be used in a program which might have an infinite loop. We could not find any neater solution for this problem. Another challenge was when we wanted to catch if any segmentation fault would occur in the debugger due to the broken assembly code. This would have caused the debugger to crash with a  segmentation fault. After looking into how to design a signal handler in C, as a group we decided to drop the idea of making our own signal handler and carry out checks to see if any segmentation fault could have occurred by checking if all registers and the memory locations being accessed existed. Another functionality of the debugger which we had great difficulty in implementing was using the up and down arrow keys to get to the previous and the next command. This would have involved to keep a double linked list with a pointer to the current command. We starteded implementing it but then great problems were encountered to read the arrow keys from the terminal.\\



else




We had planned to include modularity in our code since there where methods that where common in the assembly and the debugger such as getRegisterNumber. There was also common methods between debugger and emulator such as carryOutInstructions. However when we tried to split the code up, we encountered errors and places where somethings were declared twice. We had successfully implemented modularity for assemble however due to the lack of time we failed to finish it for the Debugger therefore we had to shelve our plans and submit a file with all the methods in it. this was a very big file and really hard to read however it compiled and worked. It would also be difficult for a person to change the code as they would have to search it will have to change it lots of places.
the other challenges we faced as a group was when we started doing the function to allow the user to step back. The first solution we though was to make a double linked list and store each state of the processor but this idea was dropped due to the amount of memory which could be used in a program which might have an infinite loop. We could not find any neater solution for this problem.
Another challenge was when we wanted to catch if any segmentation fault would occur in the debugger due to the broken assembly code. This would have caused the debugger to crash with a  segmentation fault. After looking into how to design a signal handler in C, as a group we decided to drop the idea of making our own signal handler and carry out checks to see if any segmentation fault could have occurred by checking if all registers and the memory locations being accessed existed.Another functionality of the debugger which we had great difficulty in implementing was using the up and down arrow keys to get to the previous and the next command. This would have involved to keep a double linked list with a pointer to the current command. We starteded implementing it but then great problems were encountered to read the arrow keys from the terminal.
